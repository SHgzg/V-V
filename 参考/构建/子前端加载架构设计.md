# V-V PKM 子前端加载架构设计

> 遵循插件与子前端构建隔离规范 v1

## 一、当前问题分析

### 1.1 现有架构的局限性

```
当前结构:
renderer/
├── index.html          ← 固定的单一入口
└── renderer.js         ← 固定的单一 bundle
    ↓ electron-vite 打包
out/renderer/
└── assets/index-[hash].js  ← 只有一个 JS bundle
```

**限制**:
- ❌ renderer 只能打包一个前端项目
- ❌ 无法动态加载外部前端应用
- ❌ 不支持子前端插拔
- ❌ 违反构建隔离规范

### 1.2 应该的架构（符合规范）

```
apps/desktop/
├── renderer/           ← Renderer Host（宿主，轻量级）
│   ├── index.html
│   ├── host.js         ← 子前端加载器
│   └── router/         ← 子前端路由管理
│
├── sub-frontends/      ← 子前端（独立构建、独立技术栈）
│   ├── blog/           ← 可选：博客前端
│   │   ├── dist/
│   │   └── package.json
│   ├── diary/          ← 可选：日记前端
│   │   ├── dist/
│   │   └── package.json
│   └── reader/         ← 可选：阅读器前端
│       ├── dist/
│       └── package.json
│
└── plugins/            ← Node 侧插件（后端能力）
    └── ...
```

## 二、Renderer Host 职责

### 2.1 Renderer Host 应该是什么

**Renderer Host 不是完整的前端应用**，而是：

1. **Shell 容器**：提供基础的窗口框架
2. **子前端加载器**：动态加载和卸载子前端
3. **路由分发器**：管理子前端之间的切换
4. **IPC Bridge**：子前端与主进程通信的桥梁
5. **状态管理**：跨子前端的状态共享

### 2.2 Renderer Host 不应该做什么

- ❌ 包含具体的业务逻辑
- ❌ 包含 UI 组件库（除基础框架外）
- ❌ 直接渲染子前端的代码
- ❌ 与子前端共享依赖

## 三、子前端加载方案

### 方案 A: iframe 加载（推荐，最安全）

```typescript
// renderer/host.js
class SubFrontendLoader {
  private container: HTMLElement
  private currentIframe: HTMLIFrameElement | null = null

  loadSubFrontend(name: string, url: string) {
    // 卸载旧的子前端
    if (this.currentIframe) {
      this.container.removeChild(this.currentIframe)
    }

    // 创建新的 iframe
    const iframe = document.createElement('iframe')
    iframe.src = url
    iframe.sandbox = 'allow-scripts allow-same-origin allow-forms'
    iframe.style.cssText = 'width:100%;height:100%;border:none;'

    this.container.appendChild(iframe)
    this.currentIframe = iframe
  }
}
```

**优点**:
- ✅ 完全隔离，子前端无法访问 Renderer Host
- ✅ 支持 CSP（内容安全策略）
- ✅ 可以独立卸载和加载
- ✅ 每个子前端可以使用任意技术栈

**缺点**:
- ❌ 跨 iframe 通信需要 postMessage
- ❌ 需要处理 iframe 高度自适应

### 方案 B: WebView 加载（Electron 专属）

```typescript
const webview = document.createElement('webview')
webview.src = 'file:///path/to/sub-frontend/index.html'
webview.addEventListener('dom-ready', () => {
  webview.openDevTools()
})
```

**优点**:
- ✅ Electron 原生支持
- ✅ 可以直接访问 preload API（需要配置）
- ✅ 更好的性能

**缺点**:
- ❌ 安全性相对较低
- ❌ 仅限 Electron 环境

### 方案 C: 独立 BrowserWindow

```typescript
// main/sub-frontend.ts
import { BrowserWindow } from 'electron'

function openSubFrontend(url: string) {
  const win = new BrowserWindow({
    width: 800,
    height: 600,
    webPreferences: {
      preload: path.join(__dirname, 'preload-sub.js'),
      contextIsolation: true,
      nodeIntegration: false
    }
  })

  win.loadURL(url)
}
```

**优点**:
- ✅ 完全独立的进程
- ✅ 最佳隔离性
- ✅ 支持多窗口

**缺点**:
- ❌ 资源占用较高
- ❌ 窗口管理复杂

## 四、子前端构建策略

### 4.1 子前端不在 Monorepo 中构建

```
❌ 错误做法:
apps/desktop/
├── renderer/
│   ├── blog/       ← 不要放在这里！
│   └── diary/      ← 不要放在这里！

✅ 正确做法:
apps/desktop/
├── renderer/       ← Renderer Host（轻量）
│   └── host.js
│
sub-frontends/      ← 独立目录（可选在 monorepo 外部）
├── blog/
│   ├── package.json
│   ├── vite.config.ts  ← 独立构建配置
│   └── dist/
└── diary/
    ├── package.json
    ├── webpack.config.js  ← 可以使用不同构建工具
    └── dist/
```

### 4.2 子前端独立构建流程

```bash
# 子前端使用自己的构建工具
cd sub-frontends/blog
pnpm build  # 使用 Vite/Next.js/Nuxt 等
# → 生成 dist/

# 子前端不参与 electron-vite 构建
# electron-vite 只构建 Renderer Host
```

### 4.3 子前端加载路径

```typescript
// 开发环境
const devMode = process.env.NODE_ENV !== 'production'
const subFrontendUrl = devMode
  ? 'http://localhost:5173'  // 子前端开发服务器
  : 'file:///path/to/sub-frontends/blog/dist/index.html'
```

## 五、通信机制

### 5.1 子前端 ↔ Renderer Host

```typescript
// Renderer Host
window.addEventListener('message', (event) => {
  const { type, payload } = event.data
  if (type === 'sub-frontend:ready') {
    // 子前端已加载
  }
})

// 子前端
window.parent.postMessage({
  type: 'sub-frontend:ready',
  payload: { name: 'blog' }
}, '*')
```

### 5.2 子前端 ↔ Main Process

```typescript
// 通过 Renderer Host 转发
// 子前端 → Renderer Host → Main Process

// 子前端
window.parent.postMessage({
  type: 'ipc:invoke',
  payload: {
    channel: 'git:status',
    args: [repo]
  }
}, '*')

// Renderer Host
window.addEventListener('message', async (event) => {
  const { type, payload } = event.data
  if (type === 'ipc:invoke') {
    const result = await window.electronAPI.git.status(payload.args[0])
    // 回传结果给子前端
    event.source.postMessage({ type: 'ipc:result', id: payload.id, result }, '*')
  }
})
```

## 六、实现计划

### Phase 1: Renderer Host 改造
- [ ] 精简 renderer 为纯宿主
- [ ] 实现子前端加载器（iframe 方案）
- [ ] 实现路由管理
- [ ] 实现 IPC Bridge

### Phase 2: 子前端示例
- [ ] 创建第一个子前端（如：blog）
- [ ] 配置独立构建
- [ ] 实现通信层

### Phase 3: 子前端管理
- [ ] 子前端清单（manifest）
- [ ] 动态发现和加载
- [ ] 版本管理

## 七、文件结构示例

```
apps/desktop/
├── renderer/               # Renderer Host
│   ├── index.html
│   ├── host/
│   │   ├── index.ts        # 主入口
│   │   ├── loader.ts       # 子前端加载器
│   │   ├── router.ts       # 路由管理
│   │   └── bridge.ts       # IPC Bridge
│   └── components/
│       └── AppShell.vue    # 基础框架
│
├── main/
│   ├── sub-frontends/      # 子前端管理（主进程侧）
│   │   └── manager.ts
│   └── ...
│
└── sub-frontends/          # 子前端目录（可选）
    └── blog/               # 示例子前端
        ├── package.json
        ├── vite.config.ts
        ├── src/
        └── dist/
```

## 八、构建配置调整

### 8.1 electron.vite.config.ts

```typescript
export default defineConfig({
  main: { /* ... */ },
  preload: { /* ... */ },

  // renderer 只构建 Renderer Host
  renderer: {
    root: 'renderer',
    build: {
      rollupOptions: {
        input: 'renderer/index.html'
      }
    }
  }
})
```

### 8.2 子前端独立构建

```json
// sub-frontends/blog/package.json
{
  "name": "@v-v/sub-frontend-blog",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  }
}
```

## 九、总结

**核心原则**：
1. Renderer Host ≠ 完整前端应用
2. 子前端完全独立构建、独立技术栈
3. 通过隔离机制加载（iframe/WebView）
4. 通信通过 postMessage/IPC Bridge

**优势**：
- ✅ 前端可以无限扩展
- ✅ 子前端可以独立开发和部署
- ✅ 支持多种前端技术栈共存
- ✅ 符合构建隔离规范
